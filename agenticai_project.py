# -*- coding: utf-8 -*-
"""agenticai_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c8JNNAJbjj06tO2tWo4QuCN8Kg1pWY6_
"""

#pandas → for data handling (CSV, tables, grouping)
#numpy → numerical operations (means, arrays)
#random → randomness for exploration and rewards

import pandas as pd
import numpy as np
import random

#StandardScaler → normalizes features so they have a mean=0 and a standard deviation=1
#cosine_similarity → measures similarity between user taste and song features

from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity

df = pd.read_csv("spotify_data.csv")
df.head()

#These are numerical song features used to model music taste
#These are the only features used for similarity

AUDIO_FEATURES = [
    "danceability",
    "energy",
    "loudness",
    "speechiness",
    "acousticness",
    "instrumentalness",
    "liveness",
    "valence",
    "tempo"
]

#Prevents features like tempo or loudness from dominating similarity

scaler = StandardScaler()
df[AUDIO_FEATURES] = scaler.fit_transform(df[AUDIO_FEATURES])

#Item (song) feature matrix

#Drops duplicate rows of songs
#Sets the song_id as the index
#Keeps only audio features

item_features = (
    df.drop_duplicates(subset="song_id")
      .set_index("song_id")[AUDIO_FEATURES]
)

#User profile creation

#Groups using the user_id having columns only in AUDIO_FEATURES
#Take the average of the AUDIO_FEATURES for a particular user

user_profiles = (
    df.groupby("user_id")[AUDIO_FEATURES]
      .mean()
)

#Track metadata lookup

#Drop duplicate rows with duplicate songs
#Set the sond_id as the index and take only "trackname", "artistname", "playlistname" columns
#Convert them to a dictionery

#orient="index" means
#   1. Each row index becomes a dictionary key
#   2. Each row becomes a nested dictionary


track_lookup = (
    df.drop_duplicates(subset="song_id")
      .set_index("song_id")[["trackname", "artistname", "playlistname"]]
      .to_dict(orient="index")
)

#example:
#{
#  "S1": {
#      "trackname": "Abandon Window",
#      "artistname": "Jon Hopkins",
#      "playlistname": "CHILL"
#  },
#  "S2": {
#      "trackname": "Clearing",
#      "artistname": "Grouper",
#      "playlistname": "CHILL"
#  }
#}

#Creating an empty dictionery to store songs already recommended to a user

user_history = {}

def content_recommend(user_id, k=5):
    if user_id not in user_profiles.index:
        return df.sample(k)["song_id"].tolist()

    user_vec = user_profiles.loc[user_id].values.reshape(1, -1)
    sims = cosine_similarity(user_vec, item_features.values)[0]

    ranked_songs = (
        pd.Series(sims, index=item_features.index)
        .sort_values(ascending=False)
        .index.tolist()
    )

    seen = user_history.get(user_id, set())
    ranked_songs = [s for s in ranked_songs if s not in seen]

    return ranked_songs[:k]

def playlist_explore(user_id, k=5):
    user_playlist = df[df.user_id == user_id]["playlistname"].iloc[0]
    candidates = df[df.playlistname != user_playlist]

    if len(candidates) < k:
        candidates = df

    return candidates.sample(k)["song_id"].tolist()

ACTIONS = ["CONTENT", "PLAYLIST_EXPLORE"]
epsilon = 0.3

action_rewards = {a: [] for a in ACTIONS}

def select_action():
    if random.random() < epsilon:
        return random.choice(ACTIONS)

    avg_rewards = {
        a: np.mean(action_rewards[a]) if action_rewards[a] else 0
        for a in ACTIONS
    }
    return max(avg_rewards, key=avg_rewards.get)

def recommend(user_id, k=10):
    action = select_action()

    if action == "CONTENT":
        recs = content_recommend(user_id, k)
    else:
        recs = playlist_explore(user_id, k)

    return recs, action

def compute_reward(user_id, song_id):
    user_vec = user_profiles.loc[user_id].values
    song_vec = item_features.loc[song_id].values

    sim = cosine_similarity(
        user_vec.reshape(1, -1),
        song_vec.reshape(1, -1)
    )[0][0]

    if sim > 0.75:
        return random.choice([3, 1])
    elif sim > 0.45:
        return random.choice([1, -2])
    else:
        return -2

def agentic_step(user_id):
    recs, action = recommend(user_id)

    chosen_song = random.choice(recs[:5])
    user_history.setdefault(user_id, set()).add(chosen_song)

    reward = compute_reward(user_id, chosen_song)
    action_rewards[action].append(reward)

    info = track_lookup.get(chosen_song, {})

    return {
        "user_id": user_id,
        "strategy": action,
        "song": info.get("trackname", "Unknown"),
        "artist": info.get("artistname", "Unknown"),
        "playlist": info.get("playlistname", "Unknown"),
        "reward": reward
    }

sample_user = df.sample(1)["user_id"].values[0]

for i in range(100):
    print(agentic_step(sample_user))

print(action_rewards)

print(user_history)

if __name__ == "__main__":
    sample_user = df.sample(1)["user_id"].values[0]
    for i in range(5):
        print(agentic_step(sample_user))